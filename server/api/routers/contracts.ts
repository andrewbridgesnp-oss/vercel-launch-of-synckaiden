import { z } from "zod";
import { TRPCError } from "@trpc/server";
import { protectedProcedure, router } from "../../_core/trpc";
import { getDb } from "../../db";
import { contracts, approvals } from "../../../drizzle/schema";
import { eq, and, desc } from "drizzle-orm";
import { invokeLLM } from "../../_core/llm";

export const contractsRouter = router({
  // List all contracts for workspace
  list: protectedProcedure
    .input(z.object({ workspaceId: z.number() }))
    .query(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      const results = await db
        .select()
        .from(contracts)
        .where(eq(contracts.workspaceId, input.workspaceId))
        .orderBy(desc(contracts.createdAt));

      return results;
    }),

  // Get single contract
  get: protectedProcedure
    .input(z.object({ id: z.number() }))
    .query(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      const result = await db
        .select()
        .from(contracts)
        .where(eq(contracts.id, input.id))
        .limit(1);

      if (result.length === 0) {
        throw new TRPCError({ code: "NOT_FOUND", message: "Contract not found" });
      }

      return result[0];
    }),

  // Generate contract with AI
  generate: protectedProcedure
    .input(
      z.object({
        workspaceId: z.number(),
        type: z.string(),
        parties: z.array(
          z.object({
            name: z.string(),
            role: z.string(),
            email: z.string().optional(),
          })
        ),
        terms: z.object({
          duration: z.string().optional(),
          compensation: z.string().optional(),
          scope: z.string().optional(),
          customTerms: z.array(z.string()).optional(),
        }),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Build prompt for AI contract generation
      const partiesText = input.parties
        .map((p) => `${p.role}: ${p.name}${p.email ? ` (${p.email})` : ""}`)
        .join("\n");

      const termsText = [
        input.terms.duration && `Duration: ${input.terms.duration}`,
        input.terms.compensation && `Compensation: ${input.terms.compensation}`,
        input.terms.scope && `Scope: ${input.terms.scope}`,
        ...(input.terms.customTerms || []),
      ]
        .filter(Boolean)
        .join("\n");

      const prompt = `Generate a professional ${input.type} contract with the following details:

PARTIES:
${partiesText}

TERMS:
${termsText}

Please generate a complete, legally-sound contract with:
1. Standard contract header with title and date
2. Recitals (WHEREAS clauses)
3. Definitions section
4. Rights and obligations of each party
5. Payment terms (if applicable)
6. Term and termination clauses
7. Confidentiality provisions
8. Dispute resolution
9. General provisions (governing law, amendments, etc.)
10. Signature blocks

Format the contract professionally with proper sections and numbering.

IMPORTANT DISCLAIMER: Add at the end:
"This contract was generated by AI and should be reviewed by a licensed attorney before signing. This does not constitute legal advice."`;

      try {
        const response = await invokeLLM({
          messages: [
            {
              role: "system",
              content:
                "You are a legal contract drafting assistant. Generate professional, clear contracts following standard legal formats. Always include appropriate disclaimers.",
            },
            { role: "user", content: prompt },
          ],
        });

        const contractContent =
          typeof response.choices[0]?.message?.content === "string"
            ? response.choices[0].message.content
            : "Failed to generate contract content";

        // Save contract to database
        const result = await db.insert(contracts).values({
          workspaceId: input.workspaceId,
          title: `${input.type} - ${input.parties[0]?.name || "Untitled"}`,
          type: input.type,
          content: contractContent,
          parties: input.parties,
          status: "draft",
          metadata: { terms: input.terms },
        });

        const contractId = Number(result[0].insertId);

        return { id: contractId, content: contractContent };
      } catch (error) {
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: `Failed to generate contract: ${error}`,
        });
      }
    }),

  // Update contract
  update: protectedProcedure
    .input(
      z.object({
        id: z.number(),
        title: z.string().optional(),
        content: z.string().optional(),
        status: z.enum(["draft", "pending_review", "approved", "signed", "expired"]).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      const { id, ...updates } = input;

      await db.update(contracts).set(updates).where(eq(contracts.id, id));

      return { success: true };
    }),

  // Request lawyer review
  requestReview: protectedProcedure
    .input(
      z.object({
        contractId: z.number(),
        workspaceId: z.number(),
        lawyerId: z.number(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Update contract status
      await db
        .update(contracts)
        .set({ status: "pending_review" })
        .where(eq(contracts.id, input.contractId));

      // Create approval request
      const result = await db.insert(approvals).values({
        workspaceId: input.workspaceId,
        type: "contract",
        entityId: input.contractId,
        requestedBy: ctx.user.id,
        approverId: input.lawyerId,
        status: "pending",
        notes: input.notes,
      });

      return { success: true, approvalId: Number(result[0].insertId) };
    }),

  // Approve contract (lawyer only)
  approve: protectedProcedure
    .input(
      z.object({
        contractId: z.number(),
        approvalId: z.number(),
        notes: z.string().optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Update contract status
      await db
        .update(contracts)
        .set({
          status: "approved",
          reviewedBy: ctx.user.id,
          reviewedAt: new Date(),
        })
        .where(eq(contracts.id, input.contractId));

      // Update approval
      await db
        .update(approvals)
        .set({
          status: "approved",
          approvedAt: new Date(),
          notes: input.notes,
        })
        .where(eq(approvals.id, input.approvalId));

      return { success: true };
    }),

  // Reject contract
  reject: protectedProcedure
    .input(
      z.object({
        contractId: z.number(),
        approvalId: z.number(),
        reason: z.string(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      // Update contract status back to draft
      await db
        .update(contracts)
        .set({
          status: "draft",
          reviewedBy: ctx.user.id,
          reviewedAt: new Date(),
        })
        .where(eq(contracts.id, input.contractId));

      // Update approval
      await db
        .update(approvals)
        .set({
          status: "rejected",
          notes: input.reason,
        })
        .where(eq(approvals.id, input.approvalId));

      return { success: true };
    }),

  // Delete contract
  delete: protectedProcedure
    .input(z.object({ id: z.number() }))
    .mutation(async ({ ctx, input }) => {
      const db = await getDb();
      if (!db) throw new TRPCError({ code: "INTERNAL_SERVER_ERROR", message: "Database unavailable" });

      await db.delete(contracts).where(eq(contracts.id, input.id));

      return { success: true };
    }),

  // Get contract templates
  getTemplates: protectedProcedure.query(async () => {
    return [
      {
        id: "nda",
        name: "Non-Disclosure Agreement (NDA)",
        description: "Protect confidential information shared between parties",
        category: "Legal",
      },
      {
        id: "service-agreement",
        name: "Service Agreement",
        description: "Define terms for services provided to clients",
        category: "Business",
      },
      {
        id: "employment",
        name: "Employment Contract",
        description: "Formalize employment terms and conditions",
        category: "HR",
      },
      {
        id: "consulting",
        name: "Consulting Agreement",
        description: "Establish terms for consulting services",
        category: "Business",
      },
      {
        id: "partnership",
        name: "Partnership Agreement",
        description: "Define partnership structure and responsibilities",
        category: "Business",
      },
      {
        id: "independent-contractor",
        name: "Independent Contractor Agreement",
        description: "Engage contractors with clear terms",
        category: "Business",
      },
    ];
  }),
});
